{"ast":null,"code":"import { EventEmitter, Component, forwardRef, ChangeDetectionStrategy, KeyValueDiffers, NgZone, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"ref\"];\n\nfunction normalizeLineEndings(str) {\n  if (!str) {\n    return str;\n  }\n\n  return str.replace(/\\r\\n|\\r/g, '\\n');\n}\n\nlet CodemirrorComponent = /*#__PURE__*/(() => {\n  class CodemirrorComponent {\n    constructor(_differs, _ngZone) {\n      this._differs = _differs;\n      this._ngZone = _ngZone;\n      /* class applied to the created textarea */\n\n      this.className = '';\n      /* name applied to the created textarea */\n\n      this.name = 'codemirror';\n      /* autofocus setting applied to the created textarea */\n\n      this.autoFocus = false;\n      /* preserve previous scroll position after updating value */\n\n      this.preserveScrollPosition = false;\n      /* called when the text cursor is moved */\n\n      this.cursorActivity = new EventEmitter();\n      /* called when the editor is focused or loses focus */\n\n      this.focusChange = new EventEmitter();\n      /* called when the editor is scrolled */\n      // tslint:disable-next-line:no-output-native\n\n      this.scroll = new EventEmitter();\n      /* called when file(s) are dropped */\n      // tslint:disable-next-line:no-output-native\n\n      this.drop = new EventEmitter();\n      this.value = '';\n      this.disabled = false;\n      this.isFocused = false;\n      /** Implemented as part of ControlValueAccessor. */\n\n      this.onChange = _ => {};\n      /** Implemented as part of ControlValueAccessor. */\n\n\n      this.onTouched = () => {};\n    }\n    /**\n     * set options for codemirror\n     * @link http://codemirror.net/doc/manual.html#config\n     */\n\n\n    set options(value) {\n      this._options = value;\n\n      if (!this._differ && value) {\n        this._differ = this._differs.find(value).create();\n      }\n    }\n\n    get codeMirrorGlobal() {\n      if (this._codeMirror) {\n        return this._codeMirror;\n      }\n\n      this._codeMirror = typeof CodeMirror !== 'undefined' ? CodeMirror : require('codemirror');\n      return this._codeMirror;\n    }\n\n    ngAfterViewInit() {\n      if (!this.ref) {\n        return;\n      } // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors\n\n\n      this._ngZone.runOutsideAngular(() => {\n        this.codeMirror = this.codeMirrorGlobal.fromTextArea(this.ref.nativeElement, this._options);\n        this.codeMirror.on('cursorActivity', cm => this._ngZone.run(() => this.cursorActive(cm)));\n        this.codeMirror.on('scroll', this.scrollChanged.bind(this));\n        this.codeMirror.on('blur', () => this._ngZone.run(() => this.focusChanged(false)));\n        this.codeMirror.on('focus', () => this._ngZone.run(() => this.focusChanged(true)));\n        this.codeMirror.on('change', (cm, change) => this._ngZone.run(() => this.codemirrorValueChanged(cm, change)));\n        this.codeMirror.on('drop', (cm, e) => {\n          this._ngZone.run(() => this.dropFiles(cm, e));\n        });\n        this.codeMirror.setValue(this.value);\n      });\n    }\n\n    ngDoCheck() {\n      if (!this._differ) {\n        return;\n      } // check options have not changed\n\n\n      const changes = this._differ.diff(this._options);\n\n      if (changes) {\n        changes.forEachChangedItem(option => this.setOptionIfChanged(option.key, option.currentValue));\n        changes.forEachAddedItem(option => this.setOptionIfChanged(option.key, option.currentValue));\n        changes.forEachRemovedItem(option => this.setOptionIfChanged(option.key, option.currentValue));\n      }\n    }\n\n    ngOnDestroy() {\n      // is there a lighter-weight way to remove the cm instance?\n      if (this.codeMirror) {\n        this.codeMirror.toTextArea();\n      }\n    }\n\n    codemirrorValueChanged(cm, change) {\n      if (change.origin !== 'setValue') {\n        this.value = cm.getValue();\n        this.onChange(this.value);\n      }\n    }\n\n    setOptionIfChanged(optionName, newValue) {\n      if (!this.codeMirror) {\n        return;\n      } // cast to any to handle strictly typed option names\n      // could possibly import settings strings available in the future\n\n\n      this.codeMirror.setOption(optionName, newValue);\n    }\n\n    focusChanged(focused) {\n      this.onTouched();\n      this.isFocused = focused;\n      this.focusChange.emit(focused);\n    }\n\n    scrollChanged(cm) {\n      this.scroll.emit(cm.getScrollInfo());\n    }\n\n    cursorActive(cm) {\n      this.cursorActivity.emit(cm);\n    }\n\n    dropFiles(cm, e) {\n      this.drop.emit([cm, e]);\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    writeValue(value) {\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      if (!this.codeMirror) {\n        this.value = value;\n        return;\n      }\n\n      const cur = this.codeMirror.getValue();\n\n      if (value !== cur && normalizeLineEndings(cur) !== normalizeLineEndings(value)) {\n        this.value = value;\n\n        if (this.preserveScrollPosition) {\n          const prevScrollPosition = this.codeMirror.getScrollInfo();\n          this.codeMirror.setValue(this.value);\n          this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);\n        } else {\n          this.codeMirror.setValue(this.value);\n        }\n      }\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /** Implemented as part of ControlValueAccessor. */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this.setOptionIfChanged('readOnly', this.disabled);\n    }\n\n  }\n\n  CodemirrorComponent.ɵfac = function CodemirrorComponent_Factory(t) {\n    return new (t || CodemirrorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.KeyValueDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  CodemirrorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CodemirrorComponent,\n    selectors: [[\"ngx-codemirror\"]],\n    viewQuery: function CodemirrorComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ref = _t.first);\n      }\n    },\n    inputs: {\n      className: \"className\",\n      name: \"name\",\n      autoFocus: \"autoFocus\",\n      preserveScrollPosition: \"preserveScrollPosition\",\n      options: \"options\"\n    },\n    outputs: {\n      cursorActivity: \"cursorActivity\",\n      focusChange: \"focusChange\",\n      scroll: \"scroll\",\n      drop: \"drop\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => CodemirrorComponent),\n      multi: true\n    }])],\n    decls: 3,\n    vars: 7,\n    consts: [[\"autocomplete\", \"off\", 3, \"name\", \"autofocus\"], [\"ref\", \"\"]],\n    template: function CodemirrorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"textarea\", 0, 1);\n        ɵngcc0.ɵɵtext(2, \"    \");\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMapInterpolate1(\"ngx-codemirror \", ctx.className, \"\");\n        ɵngcc0.ɵɵclassProp(\"ngx-codemirror--focused\", ctx.isFocused);\n        ɵngcc0.ɵɵproperty(\"name\", ctx.name)(\"autofocus\", ctx.autoFocus);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return CodemirrorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CodemirrorModule = /*#__PURE__*/(() => {\n  class CodemirrorModule {}\n\n  CodemirrorModule.ɵfac = function CodemirrorModule_Factory(t) {\n    return new (t || CodemirrorModule)();\n  };\n\n  CodemirrorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CodemirrorModule\n  });\n  CodemirrorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return CodemirrorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CodemirrorModule, {\n    declarations: [CodemirrorComponent],\n    exports: [CodemirrorComponent]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CodemirrorComponent, CodemirrorModule }; //# sourceMappingURL=ctrl-ngx-codemirror.js.map","map":null,"metadata":{},"sourceType":"module"}